plotly_autofit_widget <- function(plt,
                                  min_right = 0,
                                  min_bottom = 0,
                                  min_left = 0,
                                  min_top = 0,
                                  force_legend_right = FALSE) {
  if (is.null(plt)) return(NULL)
  min_right <- as.numeric(if (is.null(min_right)) 0 else min_right)
  min_bottom <- as.numeric(if (is.null(min_bottom)) 0 else min_bottom)
  min_left <- as.numeric(if (is.null(min_left)) 0 else min_left)
  min_top <- as.numeric(if (is.null(min_top)) 0 else min_top)
  if (!is.finite(min_right) || min_right < 0) min_right <- 0
  if (!is.finite(min_bottom) || min_bottom < 0) min_bottom <- 0
  if (!is.finite(min_left) || min_left < 0) min_left <- 0
  if (!is.finite(min_top) || min_top < 0) min_top <- 0
  js <- paste(
    "function(el, x, data) {",
    "  var gd = el;",
    "  if (gd && gd.classList && !gd.classList.contains('plotly')) {",
    "    var inner = gd.querySelector('.plotly');",
    "    if (inner) gd = inner;",
    "  }",
    "  if (!gd) return;",
    "  var cfg = data || {};",
    "  var minRight = (cfg.minRight != null) ? cfg.minRight : 0;",
    "  var minBottom = (cfg.minBottom != null) ? cfg.minBottom : 0;",
    "  var minLeft = (cfg.minLeft != null) ? cfg.minLeft : 0;",
    "  var minTop = (cfg.minTop != null) ? cfg.minTop : 0;",
    "  var forceLegendRight = (cfg.forceLegendRight) ? true : false;",
    "  var pad = (cfg.pad != null) ? cfg.pad : 8;",
    "  var maxLoops = (cfg.maxLoops != null) ? cfg.maxLoops : 4;",
    "  var loops = 0;",
    "  var measureOverflow = function(node, svgRect, overflow) {",
    "    if (!node || !node.getBoundingClientRect) return;",
    "    var rect = node.getBoundingClientRect();",
    "    if (!rect) return;",
    "    if (rect.right > svgRect.right) {",
    "      overflow.r = Math.max(overflow.r, rect.right - svgRect.right);",
    "    }",
    "    if (rect.bottom > svgRect.bottom) {",
    "      overflow.b = Math.max(overflow.b, rect.bottom - svgRect.bottom);",
    "    }",
    "    if (rect.left < svgRect.left) {",
    "      overflow.l = Math.max(overflow.l, svgRect.left - rect.left);",
    "    }",
    "    if (rect.top < svgRect.top) {",
    "      overflow.t = Math.max(overflow.t, svgRect.top - rect.top);",
    "    }",
    "  };",
    "  var apply = function() {",
    "    if (!gd._fullLayout) return;",
    "    var svg = gd.querySelector('.main-svg');",
    "    if (!svg || !svg.getBoundingClientRect) return;",
    "    var svgRect = svg.getBoundingClientRect();",
    "    var scaleX = 1;",
    "    var scaleY = 1;",
    "    if (gd._fullLayout && isFinite(gd._fullLayout.width) &&",
    "        svgRect && isFinite(svgRect.width) && svgRect.width > 0) {",
    "      scaleX = svgRect.width / gd._fullLayout.width;",
    "    }",
    "    if (gd._fullLayout && isFinite(gd._fullLayout.height) &&",
    "        svgRect && isFinite(svgRect.height) && svgRect.height > 0) {",
    "      scaleY = svgRect.height / gd._fullLayout.height;",
    "    } else {",
    "      scaleY = scaleX;",
    "    }",
    "    if (!isFinite(scaleX) || scaleX <= 0) scaleX = 1;",
    "    if (!isFinite(scaleY) || scaleY <= 0) scaleY = scaleX;",
    "    var toLayoutX = function(val) { return val / scaleX; };",
    "    var toLayoutY = function(val) { return val / scaleY; };",
    "    var toScreenX = function(val) { return val * scaleX; };",
    "    var overflow = {r: 0, b: 0, l: 0, t: 0};",
    "    var nodes = gd.querySelectorAll('.xaxislayer-above, .xaxislayer-below, .yaxislayer-above, .yaxislayer-below, .infolayer');",
    "    nodes.forEach(function(node) {",
    "      measureOverflow(node, svgRect, overflow);",
    "    });",
    "    var margin = (gd._fullLayout.margin) ? gd._fullLayout.margin : {l: 0, r: 0, t: 0, b: 0};",
    "    var needR = margin.r + ((overflow.r > 0) ? Math.ceil(toLayoutX(overflow.r) + pad) : 0);",
    "    var relayout = {};",
    "    var changed = false;",
    "    var clearLegendClip = function() {",
    "      var legendNode = gd.querySelector('.legend');",
    "      if (!legendNode) {",
    "        gd._legendClipSeen = false;",
    "        return null;",
    "      }",
    "      gd._legendClipSeen = true;",
    "      var removed = 0;",
    "      legendNode.removeAttribute('clip-path');",
    "      legendNode.style.clipPath = 'none';",
    "      legendNode.style.overflow = 'visible';",
    "      legendNode.setAttribute('overflow', 'visible');",
    "      var clippedNodes = legendNode.querySelectorAll('[clip-path]');",
    "      clippedNodes.forEach(function(node) {",
    "        node.removeAttribute('clip-path');",
    "        node.style.clipPath = 'none';",
    "        node.style.overflow = 'visible';",
    "        node.setAttribute('overflow', 'visible');",
    "        removed += 1;",
    "      });",
    "      var remaining = legendNode.querySelectorAll('[clip-path]').length;",
    "      gd._legendClipRemaining = remaining;",
    "      return legendNode;",
    "    };",
    "    var legend = clearLegendClip();",
    "    var legendRight = null;",
    "    var legendWidth = 0;",
    "    if (legend) {",
    "      try {",
    "        if (legend.getBBox) {",
    "          var bbox = legend.getBBox();",
    "          if (bbox && isFinite(bbox.width)) legendWidth = bbox.width;",
    "          if (bbox && svg && svg.createSVGPoint && legend.getScreenCTM) {",
    "            var ctm = legend.getScreenCTM();",
    "            if (ctm) {",
    "              var pt = svg.createSVGPoint();",
    "              pt.x = bbox.x + bbox.width;",
    "              pt.y = bbox.y;",
    "              var screen = pt.matrixTransform(ctm);",
    "              if (screen && isFinite(screen.x)) legendRight = screen.x;",
    "            }",
    "          }",
    "        }",
    "      } catch (e) {}",
    "      if ((legendWidth <= 0 || legendRight === null) && legend.getBoundingClientRect) {",
    "        var rect = legend.getBoundingClientRect();",
    "        if (rect && isFinite(rect.right)) legendRight = rect.right;",
    "        if (rect && isFinite(rect.width)) legendWidth = Math.max(legendWidth, toLayoutX(rect.width));",
    "      }",
    "      var textMax = 0;",
    "      var legendFontSize = 0;",
    "      var textPad = 2;",
    "      var texts = legend.querySelectorAll('text');",
    "      texts.forEach(function(t) {",
    "        if (!legendFontSize && window.getComputedStyle) {",
    "          var st = window.getComputedStyle(t);",
    "          if (st && st.fontSize) {",
    "            var fs = parseFloat(st.fontSize);",
    "            if (isFinite(fs)) legendFontSize = fs;",
    "          }",
    "        }",
    "        var x = parseFloat(t.getAttribute('x') || 0);",
    "        var len = 0;",
    "        if (t.getComputedTextLength) {",
    "          len = t.getComputedTextLength();",
    "        } else if (t.getBBox) {",
    "          var tb = t.getBBox();",
    "          if (tb) {",
    "            x = tb.x;",
    "            len = tb.width;",
    "          }",
    "        }",
    "        if (isFinite(x) && isFinite(len)) {",
    "          textMax = Math.max(textMax, x + len);",
    "        }",
    "      });",
    "      if (isFinite(legendFontSize) && legendFontSize > 0) {",
    "        textPad = Math.max(textPad, Math.ceil(legendFontSize * 0.1));",
    "      }",
    "      if (textMax > 0) legendWidth = Math.max(legendWidth, textMax + textPad);",
    "    }",
    "    var plotRight = null;",
    "    if (gd._fullLayout && gd._fullLayout._size) {",
    "      plotRight = svgRect.left + toScreenX(gd._fullLayout._size.l + gd._fullLayout._size.w);",
    "    } else if (isFinite(margin.r)) {",
    "      plotRight = svgRect.right - toScreenX(margin.r);",
    "    }",
    "    var legendBuffer = 6;",
    "    var legendPadFixed = 4;",
    "    if (isFinite(legendFontSize) && legendFontSize > 0) {",
    "      legendPadFixed = Math.max(legendPadFixed, Math.ceil(legendFontSize * 0.15));",
    "    }",
    "    var legendTarget = 0;",
    "    if (legendWidth > 0) {",
    "      legendTarget = Math.ceil(legendWidth + legendBuffer + legendPadFixed);",
    "    }",
    "    var haveLegendPos = (legendRight !== null && plotRight !== null &&",
    "        isFinite(legendRight) && isFinite(plotRight));",
    "    if (haveLegendPos) {",
    "      var legendOverflow = legendRight - plotRight;",
    "      if (legendOverflow > 0) {",
    "        needR = Math.max(needR, Math.ceil(toLayoutX(legendOverflow) + legendPadFixed));",
    "      }",
    "    } else if (legendTarget > 0 && forceLegendRight) {",
    "      needR = Math.max(needR, legendTarget);",
    "    }",
    "    if (forceLegendRight) {",
    "      if (legendRight !== null && isFinite(legendRight) && svgRect) {",
    "        var overflowCanvas = legendRight - svgRect.right;",
    "        if (overflowCanvas > 1 && gd._fullLayout && isFinite(gd._fullLayout.width)) {",
    "          var newWidth = Math.ceil(gd._fullLayout.width + toLayoutX(overflowCanvas) + pad);",
    "          relayout['width'] = newWidth;",
    "          gd.style.width = newWidth + 'px';",
    "          changed = true;",
    "        }",
    "      }",
    "    }",
    "    var addB = (overflow.b > 0) ? Math.ceil(toLayoutY(overflow.b) + pad) : 0;",
    "    var addL = (overflow.l > 0) ? Math.ceil(toLayoutX(overflow.l) + pad) : 0;",
    "    var addT = (overflow.t > 0) ? Math.ceil(toLayoutY(overflow.t) + pad) : 0;",
    "    var target = {",
    "      r: Math.max(minRight, needR),",
    "      b: Math.max(minBottom, margin.b + addB),",
    "      l: Math.max(minLeft, margin.l + addL),",
    "      t: Math.max(minTop, margin.t + addT)",
    "    };",
    "    if (target.r > margin.r + 1) { relayout['margin.r'] = target.r; changed = true; }",
    "    if (target.b > margin.b + 1) { relayout['margin.b'] = target.b; changed = true; }",
    "    if (target.l > margin.l + 1) { relayout['margin.l'] = target.l; changed = true; }",
    "    if (target.t > margin.t + 1) { relayout['margin.t'] = target.t; changed = true; }",
    "    if (changed && loops < maxLoops) {",
    "      loops += 1;",
    "      Plotly.relayout(gd, relayout);",
    "    }",
    "    if (forceLegendRight) {",
    "      if (!gd._legendClipInterval) {",
    "        var clipAttempts = 0;",
    "        var maxAttempts = 50;",
    "        gd._legendClipInterval = setInterval(function() {",
    "          clipAttempts += 1;",
    "          clearLegendClip();",
    "          if (gd._legendClipSeen && !gd._legendAdjustQueued) {",
    "            gd._legendAdjustQueued = true;",
    "            setTimeout(function() {",
    "              gd._legendAdjustQueued = false;",
    "              apply();",
    "            }, 120);",
    "          }",
    "          if ((gd._legendClipSeen && gd._legendClipRemaining === 0) ||",
    "              clipAttempts >= maxAttempts) {",
    "            clearInterval(gd._legendClipInterval);",
    "            gd._legendClipInterval = null;",
    "          }",
    "        }, 100);",
    "      }",
    "    }",
    "  };",
    "  var tries = 0;",
    "  var maxTries = 80;",
    "  var attach = function() {",
    "    if (!gd || typeof Plotly === 'undefined' || !gd._fullLayout) {",
    "      if (tries < maxTries) {",
    "        tries += 1;",
    "        setTimeout(attach, 50);",
    "      }",
    "      return;",
    "    }",
    "    if (gd.on) {",
    "      gd.on('plotly_afterplot', apply);",
    "      gd.on('plotly_legenddraw', apply);",
    "    }",
    "    apply();",
    "  };",
    "  attach();",
    "}",
    sep = "\n"
  )
  htmlwidgets::onRender(
    plt,
    js,
    data = list(
      minRight = min_right,
      minBottom = min_bottom,
      minLeft = min_left,
      minTop = min_top,
      forceLegendRight = isTRUE(force_legend_right),
      pad = 8,
      maxLoops = 4
    )
  )
}
